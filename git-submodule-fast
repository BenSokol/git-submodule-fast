#!/usr/bin/env python3

# @Filename: git-submodule-fast
# @Author:   Ben Sokol
# @Email:    ben@bensokol.com
#
# Copyright (C) 2025 by Ben Sokol. All Rights Reserved.

import argparse
import enum
import logging
import os
import pathlib
import subprocess
import sys
import threading


if sys.version_info[:3] >= (3,11,0):
    @enum.verify(enum.NAMED_FLAGS)
    @enum.unique
    class STATUS(enum.IntFlag, boundary=enum.STRICT):
        success = 0
        not_git_repo = enum.auto()
        unmerged_changes = enum.auto()
        not_initialized = enum.auto()
        unable_to_checkout = enum.auto()
        git_python_not_installed = enum.auto()
else:
    class STATUS(enum.IntFlag):
        success = 0
        not_git_repo = enum.auto()
        unmerged_changes = enum.auto()
        not_initialized = enum.auto()
        unable_to_checkout = enum.auto()
        git_python_not_installed = enum.auto()


try:
    import git
except ImportError as e:
    print(e.msg)
    print("Try: `pip install GitPython` (may require sudo)")
    print("See: https://pypi.org/project/GitPython")
    sys.exit(STATUS.git_python_not_installed)


log = None

class GitSubmoduleUpdateLogging():
    class ArgparseAction(argparse._StoreConstAction):
        def __init__(self, option_strings, dest, default=logging.INFO, required=False, help=None):
            super(GitSubmoduleUpdateLogging.ArgparseAction, self).__init__( option_strings=option_strings, dest=dest, const=logging.DEBUG, default=default, required=required, help=help)

    class logging_formatter( logging.Formatter ):
        BASE_FORMAT = '%(levelname)s: %(message)s'
        INFO_FORMAT = '%(message)s'
        FILE_FORMAT = '%(file)s(%(line)s): '
        def format( self, record ):
            if 'file' in record.__dict__: self._fmt = self.FILE_FORMAT
            else: self._fmt = ''
            if record.levelno == logging.INFO: self._fmt += self.INFO_FORMAT
            else: self._fmt += self.BASE_FORMAT
            return( logging.Formatter.format( self, record ) )

    class stdout_filter( logging.Filter ):
        def filter( self, record ):
            if record.levelno > logging.WARNING: return False
            else: return True

    def __init__(self, debug_level):
        global log
        self.logger = logging.getLogger(__name__)
        formatter = self.logging_formatter()
        out_stream = logging.StreamHandler( sys.stdout )
        err_stream = logging.StreamHandler( sys.stderr )
        out_stream.addFilter( self.stdout_filter() )
        out_stream.setFormatter( formatter )
        err_stream.setFormatter( formatter )
        out_stream.setLevel( debug_level )
        err_stream.setLevel( logging.ERROR )
        self.logger.addHandler( out_stream )
        self.logger.addHandler( err_stream )
        self.logger.setLevel( debug_level )
        log = self.logger


class Timing():
    def __init__(self, enabled, total_name):
        self.enabled = enabled
        self.times = {}
        self.total_name = total_name
        self.module_time = None
        self.module_datetime = None

    def __format(self, start, end, dec=2):
        self.enable()
        ret = ""
        seconds = round(self.module_datetime.timedelta(seconds=(end - start)).total_seconds(), dec)
        struct = self.module_time.gmtime(seconds)
        while seconds > 60:
            seconds -= 60
        seconds = round(seconds, dec)
        if struct.tm_hour > 0:
            ret += str(struct.tm_hour) + " hour"
            ret += "s, " if struct.tm_hour > 1 else ", "
        if struct.tm_min > 0:
            ret += str(struct.tm_min) + " minute"
            ret += "s, " if struct.tm_min > 1 else ", "
        ret += str(seconds).ljust(4, "0") + " seconds"
        return ret

    def enable(self):
        if self.module_time is None:
            import time
            self.module_time = time

        if self.module_datetime is None:
            import datetime
            self.module_datetime = datetime

    def start(self, name):
        if self.enabled:
            self.enable()
            self.times[name] = {}
            self.times[name]['start'] = self.module_time.time()

    def end(self, name):
        if self.enabled:
            self.enable()
            if name not in self.times:
                raise RuntimeError(name + " is not in self.times.")
            self.times[name]['end'] = self.module_time.time()

    def print(self, newline_before_total=True):
        if self.enabled:
            log.info("\nTiming:")
            print_list = []
            just = 0
            root_start = None
            root_end = None
            for name, data in self.times.items():
                if 'start' not in data or 'end' not in data:
                    continue
                if data['start'] is None or data['end'] is None:
                    continue
                if name == self.total_name:
                    root_start = data['start']
                    root_end = data['end']
                else:
                    formatted_name = name.replace(self.total_name, '') + ": "
                    just = max(just, len(formatted_name))
                    print_list.append((formatted_name, self.__format(data['start'], data['end'])))
            for item in print_list:
                log.info("  " + item[0].ljust(just) + item[1])
            if root_start is not None and root_end is not None:
                if len(print_list) > 0 and newline_before_total:
                    log.info("")
                log.info("  Total: " + self.__format(root_start, root_end))

    def get_total(self):
        if self.enabled:
            root_start = None
            root_end = None
            for name, data in self.times.items():
                if 'start' not in data or 'end' not in data:
                    continue
                if data['start'] is None or data['end'] is None:
                    continue
                if name == self.total_name:
                    root_start = data['start']
                    root_end = data['end']
                    break
            return self.__format(root_start, root_end)
        else:
            return ""

    def print_total(self):
        if self.enabled:
            log.info("Time: " + self.get_total())


class GitSubmoduleUpdate():
    def __init__(self, args):
        self.init = args.init
        self.recursive = args.recursive
        self.display_timing = args.time
        self.display_timing_total_only = args.time_total
        self.noexec = args.noexec
        self.threads = args.threads
        self.results = not args.no_results

        log.debug("Using " + str(self.threads) + " threads.")
        self.status = STATUS.success
        self.initialized = False
        self.exiting = False
        self.executor = None
        if self.threads > 1:
            import concurrent.futures
            self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.threads)


        self.data_lock = threading.Lock()

        self.data_total = 0
        self.data_updated = 0
        self.data_already_uptodate = 0
        self.data_initialized = 0
        self.data_skipped = 0
        self.data_errors = 0
        self.data_init_errors = 0

    def update_data(self, status = None, data_total = None, data_updated = None, data_already_uptodate = None, data_initialized = None, data_skipped = None, data_errors = None, data_init_errors = None):
        with self.data_lock:
            if status is not None:
                self.status = self.status | status
            if data_total is not None:
                self.data_total = self.data_total + data_total
            if data_updated is not None:
                self.data_updated = self.data_updated + data_updated
            if data_already_uptodate is not None:
                self.data_already_uptodate = self.data_already_uptodate + data_already_uptodate
            if data_initialized is not None:
                self.data_initialized = self.data_initialized + data_initialized
            if data_skipped is not None:
                self.data_skipped = self.data_skipped + data_skipped
            if data_errors is not None:
                self.data_errors = self.data_errors + data_errors
            if data_init_errors is not None:
                self.data_init_errors = self.data_init_errors + data_init_errors


    def __del__(self):
        try:
            self.executor.shutdown()
        except:
            self.status = STATUS.unknown


    def setup(self):
        '''Setup. Call before run.'''
        self.__locate_git_directory()
        if self.status is STATUS.success:
            self.timing = Timing(enabled=self.display_timing or self.display_timing_total_only, total_name=self.git_root)
        return self.status == STATUS.success


    def run(self):
        '''Run GitSubmoduleUpdate'''
        log.debug("Starting GitSubmoduleUpdate")
        if not self.initialized:
            raise RuntimeError("setup must be complete before run is called.")

        # Run requested git submodule command (--init and/or --recursive) with timing if requested
        self.timing.start(self.git_root)
        try:
            self.__recursive_update(self.git_root)
        except KeyboardInterrupt:
            self.exiting = True
        if self.executor is not None:
            self.executor.shutdown()
        self.timing.end(self.git_root)

        log.debug("Finished GitSubmoduleUpdate")
        if self.results:
            if self.timing.enabled:
                log.info("Results (" + self.timing.get_total() + "): ")
            else:
                log.info("Results:")
            if self.data_updated > 0: log.info("  Updated: " + str(self.data_updated))
            if self.data_already_uptodate > 0: log.info("  Up-To-Date: " + str(self.data_already_uptodate))
            if self.data_initialized > 0: log.info("  Initialized: " + str(self.data_initialized))
            if self.data_skipped > 0: log.info("  Skipped: " + str(self.data_skipped))
            if self.data_errors > 0: log.info("  Errors: " + str(self.data_errors))
            if self.data_init_errors > 0: log.info("  Init Errors: " + str(self.data_init_errors))
            log.info("  Total submodules: " + str(self.data_total))

        if self.display_timing_total_only:
            if not self.results:
                self.timing.print_total()
        else:
            self.timing.print()


    def __locate_git_directory(self):
        '''Initializes git_root based on os.getcwd.'''
        try:
            cwd = os.getcwd()
            log.debug("cwd = " + cwd.replace('\\', '/'))
            git_repo = git.Repo(cwd, search_parent_directories=True)
            git_root = git_repo.git.rev_parse("--show-toplevel")
            self.git_root = git_root
            log.debug("git root = " + self.git_root)
        except git.exc.InvalidGitRepositoryError:
            log.critical("fatal: not a git repository (or any of the parent directories): .git")
            self.status = STATUS.not_git_repo
            return False
        except:
            log.critical("ERROR: unknown error occured in GitSubmoduleUpdate:init\n")
            self.status = STATUS.unknown
            return False
        self.initialized = True
        return True


    def __gitdir(self, path):
        '''Get the --git-dir flag for a given path to a .git folder'''
        return '--git-dir=' + path + '/.git'


    def __recursive_update(self, git_root):
        '''Function called to recursively update directories.'''
        to_update, to_init = self.__get_modules_to_update(git_root)

        # Alwaus run init in single thread to prevent collisions in .git/config
        # __init_dir() will attempt to run the actual update command in executor
        for data in to_init: self.__init_dir(*data)

        if self.threads > 1:
            for data in to_update: self.executor.submit(self.__update_dir, *data)
        else:
            for data in to_update: self.__update_dir(*data)


    def __get_modules_to_update(self, git_root):
        '''Get modules in git_root. Returns to_update, to_init lists.'''
        all_files = subprocess.check_output(['git', self.__gitdir(git_root), 'ls-files', '--stage']).decode().splitlines()
        modules = [ m for m in all_files if m.startswith("160000") ]  # magic number indicating submodule
        self.update_data(data_total=len(modules))
        to_update = []
        to_init = []
        unmerged = set()
        for line in modules:
            _, target_hash, stage, path = line.split()
            abspath = os.path.join(self.git_root, path).replace('\\', '/')

            # Check for initialization. For now, leave that operation to the standard git submodule script
            if not os.path.exists(os.path.join(abspath, '.git')):
                to_init.append((git_root, path, abspath, target_hash))
                continue

            # Check for unmerged submodules.
            if int(stage) != 0:
                self.update_data(data_skipped=1)
                self.status = STATUS.unmerged_changes
                if path not in unmerged:
                    unmerged.add(path)
                    log.warning( "Skipping unmerged submodule %s" % (path) )
                continue
            to_update.append((path, abspath, target_hash))
        return to_update, to_init


    def __init_dir(self, git_root, path, abspath, target_hash):
        '''Initializes a git dir via builtin git submodule init, then runs __init_update_dir on the dir'''
        if self.init:
            self.update_data(data_initialized=1)
            self.timing.start('init ' + path)
            if not self.noexec:
                ret = subprocess.check_call(["git", self.__gitdir(git_root), "submodule", "init", path])
                if ret != 0:
                    self.update_data(data_init_errors=1)

            if self.threads > 1:
                self.executor.submit(self.__init_update_dir, git_root, path)
            else:
                self.__init_update_dir(git_root, path)
        else:
            self.status = STATUS.not_initialized
            self.update_data(data_skipped=1)
            log.warning( "Unable to checkout '%s' in submodule path '%s'\nThis submodule has not been initialized. Use the '--init' flag to initialize." % (git_root, path) )


    def __init_update_dir(self, git_root, path):
        '''Initializes a git dir via builtin git submodule update --init, then runs __update_dir on the dir'''
        if not self.noexec:
            ret = subprocess.check_call(["git", self.__gitdir(git_root), "submodule", "update", "--init", path])
            if ret != 0:
                self.update_data(data_init_errors=1)
        self.timing.end('init ' + path)


    def __update_dir(self, path, abspath, target_hash):
        '''Checks out a path to the target_hash if it isnt up-to-date.'''
        self.timing.start(path)
        if self.exiting: return
        current_hash = subprocess.check_output(["git", self.__gitdir(abspath), 'rev-parse', 'HEAD']).decode().rstrip()
        if current_hash != target_hash:
            try:
                if self.exiting: return
                if not self.noexec:
                    subprocess.check_call(["git", self.__gitdir(abspath), "checkout", "-q", target_hash])
                log.info( "Submodule path '%s': checked out '%s'" % (path, target_hash) )
                if self.exiting: return
                if self.recursive:
                    self.__recursive_update(abspath)
                self.update_data(data_updated=1)
            except subprocess.CalledProcessError:
                self.update_data(data_errors=1)
                self.status = STATUS.unable_to_checkout
                log.warning( "Unable to checkout '%s' in submodule path '%s'" % (target_hash, path) )
        else:
            self.update_data(data_already_uptodate=1)
        self.timing.end(path)


def main():
    git_exec_path = subprocess.run(['git', '--exec-path'], stdout=subprocess.PIPE)
    parser = argparse.ArgumentParser(
        prog='git submodule update',
        description='  Faster git submodule update with init and recursive capabilities.\n  By default this runs multi-threaded up to the number of threads available.',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog='Recommended:\n'
             + '  Install: `ln -s "' + str(pathlib.Path(__file__).resolve()) + '" "' + str(git_exec_path.stdout.decode('ascii')).strip('\n') + '/"`\n'
             + '  Add git alias: `git config --global alias.sup \'submodule-fast-update --init --recursive\'\n\n'
             + 'Examples (assumes the git alias above is setup):\n'
             + '  Initialize and recursively update git submodules:\n\t`git sup')
    arg_group_flags = parser.add_argument_group("FLAGS")
    arg_group_flags.add_argument('--init', help='Initialize git submodules', action='store_true')
    arg_group_flags.add_argument('--recursive', help='Update submodules recursively', action='store_true')
    arg_group_flags.add_argument('--time', help='Print timing data per submodule', action='store_true')
    arg_group_flags.add_argument('-t', '--time_total', help='Print total timing data', action='store_true')
    arg_group_flags.add_argument('--no-results', help='Dont print results data', action='store_true')
    arg_group_flags.add_argument('--debug', help='Verbose logging', action=GitSubmoduleUpdateLogging.ArgparseAction)
    arg_group_flags.add_argument('-n', '--noexec', help='No Execute. Do not checkout submodules', action='store_true')
    arg_group_flags.add_argument('-j', '--threads', help='Number of threads to use. Default: ' + str((os.cpu_count() or 1)) + ' threads.', type=int, action='store', default=(os.cpu_count() or 1))
    args = parser.parse_args()
    GitSubmoduleUpdateLogging(args.debug)
    sup = GitSubmoduleUpdate(args)
    sup.setup()
    if sup.status == STATUS.success:
        sup.run()
    return sup.status.value


if __name__ == "__main__":
    sys.exit(main())
